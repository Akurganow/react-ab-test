/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	module.exports = {
	  Experiment: __webpack_require__(1),
	  Variant: __webpack_require__(17),
	  emitter: __webpack_require__(8),
	  experimentDebugger: __webpack_require__(19)
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	module.exports = global["Experiment"] = __webpack_require__(2);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _Experiment = __webpack_require__(4);

	var _Experiment2 = _interopRequireDefault(_Experiment);

	var _emitter = __webpack_require__(8);

	var _emitter2 = _interopRequireDefault(_emitter);

	var store = undefined;

	var noopStore = {
	  getItem: function getItem() {},
	  setItem: function setItem() {}
	};

	if (typeof window !== 'undefined' && 'localStorage' in window && window['localStorage'] !== null) {
	  try {
	    var key = '__pushtell_react__';
	    window.localStorage.setItem(key, key);
	    if (window.localStorage.getItem(key) != key) {
	      store = noopStore;
	    } else {
	      window.localStorage.removeItem(key);
	      store = window.localStorage;
	    }
	  } catch (e) {
	    store = noopStore;
	  }
	} else {
	  store = noopStore;
	}

	_emitter2["default"].addValueListener(function (experimentName, variantName, skipSave) {
	  if (skipSave) {
	    return;
	  }
	  store.setItem('PUSHTELL-' + experimentName, variantName);
	});

	exports["default"] = _react2["default"].createClass({
	  displayName: "Pushtell.LocalStorage.Experiment",
	  propTypes: {
	    name: _react2["default"].PropTypes.string.isRequired,
	    defaultValue: _react2["default"].PropTypes.string
	  },
	  win: function win() {
	    _emitter2["default"].emitWin(this.props.name);
	  },
	  getLocalStorageValue: function getLocalStorageValue() {
	    var storedValue = store.getItem('PUSHTELL-' + this.props.name);
	    if (typeof storedValue === "string") {
	      _emitter2["default"].setExperimentValue(this.props.name, storedValue, true);
	      return storedValue;
	    }
	    if (typeof this.props.defaultValue === 'string') {
	      _emitter2["default"].setExperimentValue(this.props.name, this.props.defaultValue);
	      return this.props.defaultValue;
	    }
	    var variants = _emitter2["default"].getSortedVariants(this.props.name);
	    var randomValue = variants[Math.floor(Math.random() * variants.length)];
	    _emitter2["default"].setExperimentValue(this.props.name, randomValue);
	    return randomValue;
	  },
	  render: function render() {
	    return _react2["default"].createElement(_Experiment2["default"], _extends({}, this.props, { value: this.getLocalStorageValue }));
	  }
	});
	module.exports = exports["default"];

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = React;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { "default": obj };
	}

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _reactLibWarning = __webpack_require__(6);

	var _reactLibWarning2 = _interopRequireDefault(_reactLibWarning);

	var _emitter = __webpack_require__(8);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _Variant = __webpack_require__(17);

	var _Variant2 = _interopRequireDefault(_Variant);

	exports["default"] = _react2["default"].createClass({
	  displayName: "Pushtell.Experiment",
	  propTypes: {
	    name: _react2["default"].PropTypes.string.isRequired,
	    value: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.string, _react2["default"].PropTypes.func]).isRequired
	  },
	  win: function win() {
	    _emitter2["default"].emitWin(this.props.name);
	  },
	  getInitialState: function getInitialState() {
	    var _this = this;

	    var children = {};
	    _react2["default"].Children.forEach(this.props.children, function (element) {
	      if (!_react2["default"].isValidElement(element) || element.type.displayName !== "Pushtell.Variant") {
	        var error = new Error("Pushtell Experiment children must be Pushtell Variant components.");
	        error.type = "PUSHTELL_INVALID_CHILD";
	        throw error;
	      }
	      children[element.props.name] = element;
	      _emitter2["default"].addExperimentVariant(_this.props.name, element.props.name);
	    });
	    return {
	      variants: children
	    };
	  },
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    if (nextProps.value !== this.props.value) {
	      var value = typeof nextProps.value === "function" ? nextProps.value() : nextProps.value;
	      this.setState({
	        value: value
	      });
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this2 = this;

	    var value = typeof this.props.value === "function" ? this.props.value() : this.props.value;
	    if (!this.state.variants[value]) {
	      if ("production" !== process.env.NODE_ENV) {
	        (0, _reactLibWarning2["default"])(true, 'Experiment “' + this.props.name + '” does not contain variant “' + value + '”');
	      }
	    }
	    _emitter2["default"]._incrementActiveExperiments(this.props.name);
	    _emitter2["default"].setExperimentValue(this.props.name, value);
	    _emitter2["default"].emit('play', this.props.name, value);
	    this.setState({
	      value: value
	    });
	    this.valueSubscription = _emitter2["default"].addValueListener(this.props.name, function (experimentName, variantName) {
	      _this2.setState({
	        value: variantName
	      });
	    });
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    _emitter2["default"]._decrementActiveExperiments(this.props.name);
	    this.valueSubscription.remove();
	  },
	  render: function render() {
	    return this.state.variants[this.state.value] || null;
	  }
	});
	module.exports = exports["default"];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 5 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */

	"use strict";

	var emptyFunction = __webpack_require__(7);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if ("production" !== process.env.NODE_ENV) {
	  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }

	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }

	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];});
	      console.warn(message);
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}

	module.exports = warning;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */

	function makeEmptyFunction(arg) {
	  return function() {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function() { return this; };
	emptyFunction.thatReturnsArgument = function(arg) { return arg; };

	module.exports = emptyFunction;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	module.exports = global["emitter"] = __webpack_require__(9);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _fbemitter = __webpack_require__(10);

	var values = {};
	var experiments = {};
	var activeExperiments = {};

	var PushtellEventEmitter = (function (_EventEmitter) {
	  _inherits(PushtellEventEmitter, _EventEmitter);

	  function PushtellEventEmitter() {
	    _classCallCheck(this, PushtellEventEmitter);

	    _get(Object.getPrototypeOf(PushtellEventEmitter.prototype), 'constructor', this).apply(this, arguments);
	  }

	  _createClass(PushtellEventEmitter, [{
	    key: 'emitWin',
	    value: function emitWin(experimentName) {
	      if (typeof experimentName !== 'string') {
	        throw new Error("Required argument 'experimentName' should have type 'string'");
	      }
	      this.emit("win", experimentName, values[experimentName]);
	    }
	  }, {
	    key: '_incrementActiveExperiments',
	    value: function _incrementActiveExperiments(experimentName) {
	      activeExperiments[experimentName] = activeExperiments[experimentName] || 0;
	      activeExperiments[experimentName] += 1;
	      this.emit("active", experimentName);
	    }
	  }, {
	    key: '_decrementActiveExperiments',
	    value: function _decrementActiveExperiments(experimentName) {
	      activeExperiments[experimentName] -= 1;
	      this.emit("inactive", experimentName);
	    }
	  }, {
	    key: 'addVariantListener',
	    value: function addVariantListener(experimentName, callback) {
	      if (typeof experimentName === "function") {
	        callback = experimentName;
	        return this.addListener('variant', function (_experimentName, variantName) {
	          callback(_experimentName, variantName);
	        });
	      }
	      return this.addListener('variant', function (_experimentName, variantName) {
	        if (_experimentName === experimentName) {
	          callback(_experimentName, variantName);
	        }
	      });
	    }
	  }, {
	    key: 'addValueListener',
	    value: function addValueListener(experimentName, callback) {
	      if (typeof experimentName === "function") {
	        callback = experimentName;
	        return this.addListener('value', function (_experimentName, variantName, passthrough) {
	          callback(_experimentName, variantName, passthrough);
	        });
	      }
	      return this.addListener('value', function (_experimentName, variantName, passthrough) {
	        if (_experimentName === experimentName) {
	          callback(_experimentName, variantName, passthrough);
	        }
	      });
	    }
	  }, {
	    key: 'addPlayListener',
	    value: function addPlayListener(experimentName, callback) {
	      if (typeof experimentName === "function") {
	        callback = experimentName;
	        return this.addListener('play', function (_experimentName, variantName) {
	          callback(_experimentName, variantName);
	        });
	      }
	      return this.addListener('play', function (_experimentName, variantName) {
	        if (_experimentName === experimentName) {
	          callback(_experimentName, variantName);
	        }
	      });
	    }
	  }, {
	    key: 'addWinListener',
	    value: function addWinListener(experimentName, callback) {
	      if (typeof experimentName === "function") {
	        callback = experimentName;
	        return this.addListener('win', function (_experimentName, variantName) {
	          callback(_experimentName, variantName);
	        });
	      }
	      return this.addListener('win', function (_experimentName, variantName) {
	        if (_experimentName === experimentName) {
	          callback(_experimentName, variantName);
	        }
	      });
	    }
	  }, {
	    key: 'addExperimentVariants',
	    value: function addExperimentVariants(experimentName, variantNames) {
	      var _this = this;

	      experiments[experimentName] = experiments[experimentName] || {};
	      variantNames.forEach(function (variantName) {
	        if (experiments[experimentName][variantName] !== true) {
	          _this.emit("variant", experimentName, variantName);
	        }
	        experiments[experimentName][variantName] = true;
	      });
	    }
	  }, {
	    key: 'getSortedVariants',
	    value: function getSortedVariants(experimentName) {
	      var names = Object.keys(experiments[experimentName]);
	      names.sort();
	      return names;
	    }
	  }, {
	    key: 'getActiveExperiments',
	    value: function getActiveExperiments() {
	      var response = {};
	      Object.keys(activeExperiments).forEach(function (experimentName) {
	        if (activeExperiments[experimentName] === 0) {
	          return;
	        }
	        response[experimentName] = {};
	        Object.keys(experiments[experimentName]).forEach(function (variantName) {
	          response[experimentName][variantName] = values[experimentName] === variantName;
	        });
	      });
	      return response;
	    }
	  }, {
	    key: 'getExperimentValue',
	    value: function getExperimentValue(experimentName) {
	      return values[experimentName];
	    }
	  }, {
	    key: 'setExperimentValue',
	    value: function setExperimentValue(experimentName, variantName, passthrough) {
	      values[experimentName] = variantName;
	      this.emit("value", experimentName, variantName, passthrough);
	    }
	  }, {
	    key: 'addExperimentVariant',
	    value: function addExperimentVariant(experimentName, variantName) {
	      experiments[experimentName] = experiments[experimentName] || {};
	      if (experiments[experimentName][variantName] !== true) {
	        if (values[experimentName]) {
	          var error = new Error("Expiriment “" + experimentName + "” added new variants after a variant was selected. Declare the variant names using emitter.addExpirimentVariants(expirimentName, variantNames).");
	          error.type = "PUSHTELL_INVALID_VARIANT";
	          throw error;
	        }
	        experiments[experimentName][variantName] = true;
	        this.emit("variant", experimentName, variantName);
	      } else {
	        experiments[experimentName][variantName] = true;
	      }
	    }
	  }]);

	  return PushtellEventEmitter;
	})(_fbemitter.EventEmitter);

	exports['default'] = new PushtellEventEmitter();
	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	var fbemitter = {
	  EventEmitter: __webpack_require__(11)
	};

	module.exports = fbemitter;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BaseEventEmitter
	 * @typechecks
	 */

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var EmitterSubscription = __webpack_require__(12);
	var EventSubscriptionVendor = __webpack_require__(14);

	var emptyFunction = __webpack_require__(16);
	var invariant = __webpack_require__(15);

	/**
	 * @class BaseEventEmitter
	 * @description
	 * An EventEmitter is responsible for managing a set of listeners and publishing
	 * events to them when it is told that such events happened. In addition to the
	 * data for the given event it also sends a event control object which allows
	 * the listeners/handlers to prevent the default behavior of the given event.
	 *
	 * The emitter is designed to be generic enough to support all the different
	 * contexts in which one might want to emit events. It is a simple multicast
	 * mechanism on top of which extra functionality can be composed. For example, a
	 * more advanced emitter may use an EventHolder and EventFactory.
	 */

	var BaseEventEmitter = (function () {
	  /**
	   * @constructor
	   */

	  function BaseEventEmitter() {
	    _classCallCheck(this, BaseEventEmitter);

	    this._subscriber = new EventSubscriptionVendor();
	    this._currentSubscription = null;
	  }

	  /**
	   * Adds a listener to be invoked when events of the specified type are
	   * emitted. An optional calling context may be provided. The data arguments
	   * emitted will be passed to the listener function.
	   *
	   * TODO: Annotate the listener arg's type. This is tricky because listeners
	   *       can be invoked with varargs.
	   *
	   * @param {string} eventType - Name of the event to listen to
	   * @param {function} listener - Function to invoke when the specified event is
	   *   emitted
	   * @param {*} context - Optional context object to use when invoking the
	   *   listener
	   */

	  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {
	    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));
	  };

	  /**
	   * Similar to addListener, except that the listener is removed after it is
	   * invoked once.
	   *
	   * @param {string} eventType - Name of the event to listen to
	   * @param {function} listener - Function to invoke only once when the
	   *   specified event is emitted
	   * @param {*} context - Optional context object to use when invoking the
	   *   listener
	   */

	  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {
	    var emitter = this;
	    return this.addListener(eventType, function () {
	      emitter.removeCurrentListener();
	      listener.apply(context, arguments);
	    });
	  };

	  /**
	   * Removes all of the registered listeners, including those registered as
	   * listener maps.
	   *
	   * @param {?string} eventType - Optional name of the event whose registered
	   *   listeners to remove
	   */

	  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {
	    this._subscriber.removeAllSubscriptions(eventType);
	  };

	  /**
	   * Provides an API that can be called during an eventing cycle to remove the
	   * last listener that was invoked. This allows a developer to provide an event
	   * object that can remove the listener (or listener map) during the
	   * invocation.
	   *
	   * If it is called when not inside of an emitting cycle it will throw.
	   *
	   * @throws {Error} When called not during an eventing cycle
	   *
	   * @example
	   *   var subscription = emitter.addListenerMap({
	   *     someEvent: function(data, event) {
	   *       console.log(data);
	   *       emitter.removeCurrentListener();
	   *     }
	   *   });
	   *
	   *   emitter.emit('someEvent', 'abc'); // logs 'abc'
	   *   emitter.emit('someEvent', 'def'); // does not log anything
	   */

	  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {
	    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;
	    this._subscriber.removeSubscription(this._currentSubscription);
	  };

	  /**
	   * Returns an array of listeners that are currently registered for the given
	   * event.
	   *
	   * @param {string} eventType - Name of the event to query
	   * @return {array}
	   */

	  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{
	    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
	    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {
	      return subscription.listener;
	    }) : [];
	  };

	  /**
	   * Emits an event of the given type with the given data. All handlers of that
	   * particular type will be notified.
	   *
	   * @param {string} eventType - Name of the event to emit
	   * @param {*} Arbitrary arguments to be passed to each registered listener
	   *
	   * @example
	   *   emitter.addListener('someEvent', function(message) {
	   *     console.log(message);
	   *   });
	   *
	   *   emitter.emit('someEvent', 'abc'); // logs 'abc'
	   */

	  BaseEventEmitter.prototype.emit = function emit(eventType) {
	    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
	    if (subscriptions) {
	      var keys = Object.keys(subscriptions);
	      for (var ii = 0; ii < keys.length; ii++) {
	        var key = keys[ii];
	        var subscription = subscriptions[key];
	        // The subscription may have been removed during this event loop.
	        if (subscription) {
	          this._currentSubscription = subscription;
	          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));
	        }
	      }
	      this._currentSubscription = null;
	    }
	  };

	  /**
	   * Provides a hook to override how the emitter emits an event to a specific
	   * subscription. This allows you to set up logging and error boundaries
	   * specific to your environment.
	   *
	   * @param {EmitterSubscription} subscription
	   * @param {string} eventType
	   * @param {*} Arbitrary arguments to be passed to each registered listener
	   */

	  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {
	    var args = Array.prototype.slice.call(arguments, 2);
	    subscription.listener.apply(subscription.context, args);
	  };

	  return BaseEventEmitter;
	})();

	module.exports = BaseEventEmitter;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 * 
	 * @providesModule EmitterSubscription
	 * @typechecks
	 */

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var EventSubscription = __webpack_require__(13);

	/**
	 * EmitterSubscription represents a subscription with listener and context data.
	 */

	var EmitterSubscription = (function (_EventSubscription) {
	  _inherits(EmitterSubscription, _EventSubscription);

	  /**
	   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls
	   *   this subscription
	   * @param {function} listener - Function to invoke when the specified event is
	   *   emitted
	   * @param {*} context - Optional context object to use when invoking the
	   *   listener
	   */

	  function EmitterSubscription(subscriber, listener, context) {
	    _classCallCheck(this, EmitterSubscription);

	    _EventSubscription.call(this, subscriber);
	    this.listener = listener;
	    this.context = context;
	  }

	  return EmitterSubscription;
	})(EventSubscription);

	module.exports = EmitterSubscription;

/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 * 
	 * @providesModule EventSubscription
	 * @typechecks
	 */

	'use strict';

	/**
	 * EventSubscription represents a subscription to a particular event. It can
	 * remove its own subscription.
	 */

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var EventSubscription = (function () {

	  /**
	   * @param {EventSubscriptionVendor} subscriber the subscriber that controls
	   *   this subscription.
	   */

	  function EventSubscription(subscriber) {
	    _classCallCheck(this, EventSubscription);

	    this.subscriber = subscriber;
	  }

	  /**
	   * Removes this subscription from the subscriber that controls it.
	   */

	  EventSubscription.prototype.remove = function remove() {
	    this.subscriber.removeSubscription(this);
	  };

	  return EventSubscription;
	})();

	module.exports = EventSubscription;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 * 
	 * @providesModule EventSubscriptionVendor
	 * @typechecks
	 */

	'use strict';

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var invariant = __webpack_require__(15);

	/**
	 * EventSubscriptionVendor stores a set of EventSubscriptions that are
	 * subscribed to a particular event type.
	 */

	var EventSubscriptionVendor = (function () {
	  function EventSubscriptionVendor() {
	    _classCallCheck(this, EventSubscriptionVendor);

	    this._subscriptionsForType = {};
	    this._currentSubscription = null;
	  }

	  /**
	   * Adds a subscription keyed by an event type.
	   *
	   * @param {string} eventType
	   * @param {EventSubscription} subscription
	   */

	  EventSubscriptionVendor.prototype.addSubscription = function addSubscription(eventType, subscription) {
	    !(subscription.subscriber === this) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The subscriber of the subscription is incorrectly set.') : invariant(false) : undefined;
	    if (!this._subscriptionsForType[eventType]) {
	      this._subscriptionsForType[eventType] = [];
	    }
	    var key = this._subscriptionsForType[eventType].length;
	    this._subscriptionsForType[eventType].push(subscription);
	    subscription.eventType = eventType;
	    subscription.key = key;
	    return subscription;
	  };

	  /**
	   * Removes a bulk set of the subscriptions.
	   *
	   * @param {?string} eventType - Optional name of the event type whose
	   *   registered supscriptions to remove, if null remove all subscriptions.
	   */

	  EventSubscriptionVendor.prototype.removeAllSubscriptions = function removeAllSubscriptions(eventType) {
	    if (eventType === undefined) {
	      this._subscriptionsForType = {};
	    } else {
	      delete this._subscriptionsForType[eventType];
	    }
	  };

	  /**
	   * Removes a specific subscription. Instead of calling this function, call
	   * `subscription.remove()` directly.
	   *
	   * @param {object} subscription
	   */

	  EventSubscriptionVendor.prototype.removeSubscription = function removeSubscription(subscription) {
	    var eventType = subscription.eventType;
	    var key = subscription.key;

	    var subscriptionsForType = this._subscriptionsForType[eventType];
	    if (subscriptionsForType) {
	      delete subscriptionsForType[key];
	    }
	  };

	  /**
	   * Returns the array of subscriptions that are currently registered for the
	   * given event type.
	   *
	   * Note: This array can be potentially sparse as subscriptions are deleted
	   * from it when they are removed.
	   *
	   * TODO: This returns a nullable array. wat?
	   *
	   * @param {string} eventType
	   * @return {?array}
	   */

	  EventSubscriptionVendor.prototype.getSubscriptionsForType = function getSubscriptionsForType(eventType) {
	    return this._subscriptionsForType[eventType];
	  };

	  return EventSubscriptionVendor;
	})();

	module.exports = EventSubscriptionVendor;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */

	"use strict";

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function (condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */

	"use strict";

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	module.exports = global["Variant"] = __webpack_require__(18);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	exports["default"] = _react2["default"].createClass({
	  displayName: "Pushtell.Variant",
	  propTypes: {
	    name: _react2["default"].PropTypes.string.isRequired
	  },
	  render: function render() {
	    if (_react2["default"].isValidElement(this.props.children)) {
	      return this.props.children;
	    } else {
	      return _react2["default"].createElement(
	        "span",
	        null,
	        this.props.children
	      );
	    }
	  }
	});
	module.exports = exports["default"];

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	module.exports = global["experimentDebugger"] = __webpack_require__(20);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _react = __webpack_require__(3);

	var _react2 = _interopRequireDefault(_react);

	var _emitter = __webpack_require__(8);

	var _emitter2 = _interopRequireDefault(_emitter);

	var _reactLibExecutionEnvironment = __webpack_require__(21);

	var _reactLibObjectAssign = __webpack_require__(22);

	var _reactLibObjectAssign2 = _interopRequireDefault(_reactLibObjectAssign);

	if (process.env.NODE_ENV === "production" || !_reactLibExecutionEnvironment.canUseDOM) {
	  module.exports = {
	    enable: function enable() {},
	    disable: function disable() {}
	  };
	} else {
	  (function () {
	    var attachStyleSheet = function attachStyleSheet() {
	      style = document.createElement("style");
	      style.appendChild(document.createTextNode(""));
	      document.head.appendChild(style);
	      function addCSSRule(selector, rules) {
	        if ("insertRule" in style.sheet) {
	          style.sheet.insertRule(selector + "{" + rules + "}", 0);
	        } else if ("addRule" in style.sheet) {
	          style.sheet.addRule(selector, rules, 0);
	        }
	      }
	      addCSSRule("#pushtell-debugger", "z-index: 25000");
	      addCSSRule("#pushtell-debugger", "position: fixed");
	      addCSSRule("#pushtell-debugger", "transform: translateX(-50%)");
	      addCSSRule("#pushtell-debugger", "bottom: 0");
	      addCSSRule("#pushtell-debugger", "left: 50%");
	      addCSSRule("#pushtell-debugger ul", "margin: 0");
	      addCSSRule("#pushtell-debugger ul", "padding: 0 0 0 20px");
	      addCSSRule("#pushtell-debugger li", "margin: 0");
	      addCSSRule("#pushtell-debugger li", "padding: 0");
	      addCSSRule("#pushtell-debugger li", "font-size: 14px");
	      addCSSRule("#pushtell-debugger li", "line-height: 14px");
	      addCSSRule("#pushtell-debugger input", "float: left");
	      addCSSRule("#pushtell-debugger input", "margin: 0 10px 0 0");
	      addCSSRule("#pushtell-debugger input", "padding: 0");
	      addCSSRule("#pushtell-debugger input", "cursor: pointer");
	      addCSSRule("#pushtell-debugger label", "color: #999999");
	      addCSSRule("#pushtell-debugger label", "margin: 0 0 10px 0");
	      addCSSRule("#pushtell-debugger label", "cursor: pointer");
	      addCSSRule("#pushtell-debugger label", "font-weight: normal");
	      addCSSRule("#pushtell-debugger label.active", "color: #000000");
	      addCSSRule("#pushtell-debugger .pushtell-experiment-name", "font-size: 16px");
	      addCSSRule("#pushtell-debugger .pushtell-experiment-name", "color: #000000");
	      addCSSRule("#pushtell-debugger .pushtell-experiment-name", "margin: 0 0 10px 0");
	      addCSSRule("#pushtell-debugger .pushtell-production-build-note", "font-size: 10px");
	      addCSSRule("#pushtell-debugger .pushtell-production-build-note", "color: #999999");
	      addCSSRule("#pushtell-debugger .pushtell-production-build-note", "text-align: center");
	      addCSSRule("#pushtell-debugger .pushtell-production-build-note", "margin: 10px -40px 0 -10px");
	      addCSSRule("#pushtell-debugger .pushtell-production-build-note", "border-top: 1px solid #b3b3b3");
	      addCSSRule("#pushtell-debugger .pushtell-production-build-note", "padding: 10px 10px 5px 10px");
	      addCSSRule("#pushtell-debugger .pushtell-handle", "cursor: pointer");
	      addCSSRule("#pushtell-debugger .pushtell-handle", "padding: 5px 10px 5px 10px");
	      addCSSRule("#pushtell-debugger .pushtell-panel", "padding: 15px 40px 5px 10px");
	      addCSSRule("#pushtell-debugger .pushtell-container", "font-size: 11px");
	      addCSSRule("#pushtell-debugger .pushtell-container", "background-color: #ebebeb");
	      addCSSRule("#pushtell-debugger .pushtell-container", "color: #000000");
	      addCSSRule("#pushtell-debugger .pushtell-container", "box-shadow: 0px 0 5px rgba(0, 0, 0, 0.1)");
	      addCSSRule("#pushtell-debugger .pushtell-container", "border-top: 1px solid #b3b3b3");
	      addCSSRule("#pushtell-debugger .pushtell-container", "border-left: 1px solid #b3b3b3");
	      addCSSRule("#pushtell-debugger .pushtell-container", "border-right: 1px solid #b3b3b3");
	      addCSSRule("#pushtell-debugger .pushtell-container", "border-top-left-radius: 2px");
	      addCSSRule("#pushtell-debugger .pushtell-container", "border-top-right-radius: 2px");
	      addCSSRule("#pushtell-debugger .pushtell-close", "cursor: pointer");
	      addCSSRule("#pushtell-debugger .pushtell-close", "font-size: 16px");
	      addCSSRule("#pushtell-debugger .pushtell-close", "font-weight: bold");
	      addCSSRule("#pushtell-debugger .pushtell-close", "color: #CC0000");
	      addCSSRule("#pushtell-debugger .pushtell-close", "position: absolute");
	      addCSSRule("#pushtell-debugger .pushtell-close", "top: 0px");
	      addCSSRule("#pushtell-debugger .pushtell-close", "right: 7px");
	      addCSSRule("#pushtell-debugger .pushtell-close:hover", "color: #FF0000");
	      addCSSRule("#pushtell-debugger .pushtell-close, #pushtell-debugger label", "transition: all .25s");
	    };

	    var removeStyleSheet = function removeStyleSheet() {
	      if (style !== null) {
	        document.head.removeChild(style);
	        style = null;
	      }
	    };

	    var style = null;

	    var Debugger = _react2['default'].createClass({
	      displayName: "Pushtell.Debugger",
	      getInitialState: function getInitialState() {
	        return {
	          experiments: _emitter2['default'].getActiveExperiments(),
	          visible: false
	        };
	      },
	      toggleVisibility: function toggleVisibility() {
	        this.setState({
	          visible: !this.state.visible
	        });
	      },
	      updateExperiments: function updateExperiments() {
	        this.setState({
	          experiments: _emitter2['default'].getActiveExperiments()
	        });
	      },
	      setExperimentValue: function setExperimentValue(experimentName, variantName) {
	        _emitter2['default'].setExperimentValue(experimentName, variantName);
	      },
	      componentWillMount: function componentWillMount() {
	        this.variantSubscription = _emitter2['default'].addVariantListener(this.updateExperiments);
	        this.valueSubscription = _emitter2['default'].addValueListener(this.updateExperiments);
	        this.activeSubscription = _emitter2['default'].addListener("active", this.updateExperiments);
	        this.inactiveSubscription = _emitter2['default'].addListener("inactive", this.updateExperiments);
	      },
	      componentWillUnmount: function componentWillUnmount() {
	        this.variantSubscription.remove();
	        this.valueSubscription.remove();
	        this.activeSubscription.remove();
	        this.inactiveSubscription.remove();
	      },
	      render: function render() {
	        var _this = this;

	        var experimentNames = Object.keys(this.state.experiments);
	        if (this.state.visible) {
	          return _react2['default'].createElement(
	            'div',
	            { className: 'pushtell-container pushtell-panel' },
	            _react2['default'].createElement(
	              'div',
	              { className: 'pushtell-close', onClick: this.toggleVisibility },
	              '×'
	            ),
	            experimentNames.map(function (experimentName) {
	              var variantNames = Object.keys(_this.state.experiments[experimentName]);
	              if (variantNames.length === 0) {
	                return;
	              }
	              return _react2['default'].createElement(
	                'div',
	                { className: 'pushtell-experiment', key: experimentName },
	                _react2['default'].createElement(
	                  'div',
	                  { className: 'pushtell-experiment-name' },
	                  experimentName
	                ),
	                _react2['default'].createElement(
	                  'ul',
	                  null,
	                  variantNames.map(function (variantName) {
	                    return _react2['default'].createElement(
	                      'li',
	                      { key: variantName, onClick: _this.setExperimentValue.bind(_this, experimentName, variantName) },
	                      _react2['default'].createElement(
	                        'label',
	                        { className: _this.state.experiments[experimentName][variantName] ? "active" : null },
	                        _react2['default'].createElement('input', { type: 'radio', name: experimentName, value: variantName, defaultChecked: _this.state.experiments[experimentName][variantName] }),
	                        variantName
	                      )
	                    );
	                  })
	                )
	              );
	            }),
	            _react2['default'].createElement(
	              'div',
	              { className: 'pushtell-production-build-note' },
	              'This panel is hidden on production builds.'
	            )
	          );
	        } else if (experimentNames.length > 0) {
	          return _react2['default'].createElement(
	            'div',
	            { className: 'pushtell-container pushtell-handle', onClick: this.toggleVisibility },
	            experimentNames.length,
	            ' Active Experiment',
	            experimentNames.length > 1 ? "s" : ""
	          );
	        } else {
	          return null;
	        }
	      }
	    });

	    module.exports = {
	      enable: function enable() {
	        attachStyleSheet();
	        var body = document.getElementsByTagName('body')[0];
	        var container = document.createElement('div');
	        container.id = 'pushtell-debugger';
	        body.appendChild(container);
	        _react2['default'].render(_react2['default'].createElement(Debugger, null), container);
	      },
	      disable: function disable() {
	        removeStyleSheet();
	        var body = document.getElementsByTagName('body')[0];
	        var container = document.getElementById('pushtell-debugger');
	        if (container) {
	          _react2['default'].unmountComponentAtNode(container);
	          body.removeChild(container);
	        }
	      }
	    };
	  })();
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */

	/*jslint evil: true */

	"use strict";

	var canUseDOM = !!(
	  (typeof window !== 'undefined' &&
	  window.document && window.document.createElement)
	);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners:
	    canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	module.exports = ExecutionEnvironment;


/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

	'use strict';

	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }

	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;

	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }

	    var from = Object(nextSource);

	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.

	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }

	  return to;
	}

	module.exports = assign;


/***/ }
/******/ ]);